import os
import numpy as np



number_of_samples = 10868

def is_bytes(input_file):
    ext = os.path.splitext(os.path.basename(input_file))[1]
    print('ext = ', ext)
    result = False
    if '.bytes' == ext:
        result = True
    return result



# 将byte_value这个一维数组转换为灰度图
def generate_and_save_image(input_dir, output_dir, filename):
    out_file = os.path.splitext(os.path.basename(filename))[0] + '.txt'  # 决定输出文件的格式（取决于CBOW模型的输入格式）
    out_file_full = output_dir + out_file
    input_file_path = os.path.join(input_dir, filename)
    print("out_file_full: ", out_file_full)
    if is_bytes(filename):  # 如果该文件是bytes格式的文件的话
        f = open(input_file_path)
        byte = []
        # 把 .byte文件中所有内容（除了开头的行号以及"??"），都添加到byte这个一维数组中
        for line in f:
            xx = line.split()  # 对每行，按制表符切割字符串，得到的结果构成一个数组，数组的每个元素代表一行中的一列，xx为一行的数组有17个元素
         #   if len(xx) != 17:
            if len(xx) != 16:
                continue
            for i in xx[1:]:
                if (i!='??'):
                    byte.append(i)
#           byte.append('.')   # 在每行末尾加一个'.'英文句号
        #print(len(byte))

        # 将byte一维数组中连续5次及以上的"CC"和"00"删掉（这些内容没有意义），进行文件预处理

        # 删除连续出现5次及以上的'00'
        processed_byte = []
        current = []
        count = 0
        processed_byte.append(byte[0])
        last = 'xx'
        for k in byte[1:]:
            if (k == '00'):
                count = count + 1
                current.append(k)
                last = k
            else:
                if (last == '00'):
                    if count >= 5:
                        processed_byte.append(k)
                        count = 0
                        current = []
                        last = k
                    else:
                        for j in current[0:]:
                            processed_byte.append(j)
                        processed_byte.append(k)
                        count = 0
                        current = []
                        last = k
                else:
                    processed_byte.append(k)
                    last = k
        #print(len(processed_byte))

        # 删除连续出现5次及以上的'CC'
        byte_2 = []
        current_2 = []
        count_2 = 0
        byte_2.append(processed_byte[0])
        last = 'xx'
        for m in processed_byte[1:]:
            if m == 'CC':
                count_2 = count_2 + 1
                current_2.append(m)
                last = m
            else:
                if last == 'CC':
                    if count_2 >= 5:
                        byte_2.append(m)
                        count_2 = 0
                        current_2 = []
                        last = m
                    else:
                        for n in current_2[0:]:
                            byte_2.append(n)
                        byte_2.append(m)
                        count_2 = 0
                        current_2 = []
                        last = m
                else:
                    byte_2.append(m)
                    last = m
        #print(byte_2)
        #print(type(byte_2))


        # 删除多余的'FF',每行只留一个句号（5个及5个以上的‘FF’）
#        byte_3 = []
#        current_3 = []
#        count_3 = 0
#        byte_3.append(byte_2[0])
#        last = 'xx'
#        for m3 in byte_2[1:]:
#            if m3 == 'FF':
#                count_3 = count_3 + 1
#                current_3.append(m3)
#                last = m3
#            else:
#                if last == 'FF':
#                    if count_3 >= 5:
#                        byte_3.append('FF')
#                        byte_3.append(m3)
#                        count_3 = 0
#                        current_3 = []
#                        last = m3
#                    else:
#                        for n3 in current_3[0:]:
#                            byte_3.append(n3)
#                        byte_3.append(m3)
#                        count_3 = 0
#                        current_3 = []
#                        last = m3
#                else:
#                    byte_3.append(m3)
#                    last = m3


        # 把预处理后的byte数组保存到txt文档中，保存为英文语料库格式
        file = open(out_file_full, 'w+')
        for temp in byte_2:
            print(str(temp), file=file, end=' ')
        file.close()



def convert_bin_to_img(input_dir, output_dir):
    if not os.path.isdir(input_dir):
        print(input_dir, 'Input directory not found. Exiting.')
        exit(0)
    if not os.path.isdir(output_dir):
        os.mkdir(output_dir)
    count = 0
    files = os.listdir(input_dir)
    print(files)
    for filename in files:
        print("filename: ", filename)
        try:
            generate_and_save_image(input_dir, output_dir, filename)
            print(filename)
            count += 1
            print(count)
            if number_of_samples == count:
                exit(0)
        except:
             print('Ignoring ', filename)


if __name__ == '__main__':
    convert_bin_to_img("/home/mayixuan/drit-7-dataset/bytes/after/", "drift-after-precessed/")