# Learning-Based-PE-Malware-Family-Classification-Methods
本项目包含三类基于学习的PE恶意软件家族分类方法，分别是基于图像的、基于二进制的和基于反汇编的方法，还有一种检测恶意软件类间漂移的方法。

## 基于图像的家族分类方法

## 基于二进制的家族分类方法
> **参考文献：‘Malware Classification Method Based on Word Vector of Bytes and Multilayer Perception’**
#### 1. 原始二进制文件预处理（1_process.py）
把 .byte文件中所有内容（除开头的行号以及未知字符"??"），都读取到一个一维数组中。将一维数组中连续出现5次及以上的"CC"和"00"删掉（这些连续的"CC"或"00“通常没有意义），进行文件预处理。并将处理好的内容输出到.txt文件中。
#### 2. 将每个文件作为语料库，获得文件中256个字节的嵌入向量，将每个文件表示一个词向量升序矩阵（2_CBOW-gensim.py）
将一个.txt文件作为一个英文语料库，通过python的第三方库gensim获得文件中256个字节对应的嵌入向量。其中，word2vec使用CBOW模型，嵌入向量维度为256，窗口大小为5，迭代次数为5，使用负采样算法。之后，处理训练好的词向量矩阵，按字节升序排序，这里首先判断该文件包含的词典数是否为256（即该文件是否够256字节），是的话才升序排序；否则跳过该文件，并把文件名写到.txt文件中,稍后处理（共191左右个文件被跳过）。将每个文件的词向量升序矩阵保存为对应的.csv文件。
#### 3. 可视化所有文件对应的灰度图，确认获得的词向量矩阵确实具有家族特征（3_log-to-image.py）
对获得的升序词向量升序进行处理，将每个元素标准化为[0, 255]间的整数，从而将向量矩阵转换为灰度图进行观察。
#### 4. 使用MLP模型进行恶意软件家族分类（4_10-fold-MLP.py）
输入为未标准化的升序词向量矩阵（进行flatten，获得65536维），输出为所属家族。共10860个恶意文件，训练集：验证集：测试集 = 8:1:1，随机抽样，仅进行一次训练和测试，未用十倍交叉验证。

:two_hearts::two_hearts::two_hearts::two_hearts::two_hearts::two_hearts:

> **参考文献：‘Malware Detection by Eating a Whole EXE’**
#### 1. 预处理数据（1_preprocess.py）
将二进制文件中的"??"和行首编号除去，将字节转换为整数。为了统一文件大小，用于后续的模型输入，统一将文件截断或填充为2MB大小。
#### 2、使用MalConv进行恶意软件家族分类（2_10-fold-Malconv-muti-GPU.py、2_10-fold-Malconv-single-GPU.py）
分别使用了多GPU训练（数据并行）和单个GPU训练。
#### 3、使用DeepConv进行恶意软件家族分类（3_10-fold-Deepconv.py）
#### 4、模型构建（DeepConv-model.py、MalConv-model.py）

## 基于反汇编的家族分类方法
