import os
import re
import pickle
import numpy as np
import hashlib as h

from nltk.util import ngrams
#from ttictoc import TicToc
from skimage import io



def make_hash_768(opcode_list, bits, gram):
    hash_v = np.zeros([bits[0]])

    if gram == None:

        for opcode in opcode_list:

            binary1 = bin(int(h.sha256(opcode.encode()).hexdigest(), 16))[2:]
            binary1 = list(binary1)
            temp = bits[1] - len(binary1)
            for i in range(temp):
                binary1.insert(0, '0')

            binary2 = bin(int(h.sha512(opcode.encode()).hexdigest(), 16))[2:]
            binary2 = list(binary2)
            temp = bits[2] - len(binary2)
            for i in range(temp):
                binary2.insert(0, '0')

            binary = binary2 + binary1  # SHA-512 + SHA-256
            binary = np.array(list(map(lambda x: -1 if x == '0' else 1, binary)))
            hash_v = hash_v + binary

    elif gram == 2:

        opcode_ngram_tuple = list(ngrams(opcode_list, n=gram))

        for word1, word2 in opcode_ngram_tuple:

            opcode = word1 + word2

            binary1 = bin(int(h.sha256(opcode.encode()).hexdigest(), 16))[2:]
            binary1 = list(binary1)
            temp = bits[1] - len(binary1)
            for i in range(temp):
                binary1.insert(0, '0')

            binary2 = bin(int(h.sha512(opcode.encode()).hexdigest(), 16))[2:]
            binary2 = list(binary2)
            temp = bits[2] - len(binary2)
            for i in range(temp):
                binary2.insert(0, '0')

            binary = binary2 + binary1  # SHA-512 + SHA-256
            binary = np.array(list(map(lambda x: -1 if x == '0' else 1, binary)))
            hash_v = hash_v + binary

    elif gram == 3:
        opcode_ngram_tuple = list(ngrams(opcode_list, n=gram))

        for word1, word2, word3 in opcode_ngram_tuple:

            opcode = word1 + word2 + word3

            binary1 = bin(int(h.sha256(opcode.encode()).hexdigest(), 16))[2:]
            binary1 = list(binary1)
            temp = bits[1] - len(binary1)
            for i in range(temp):
                binary1.insert(0, '0')

            binary2 = bin(int(h.sha512(opcode.encode()).hexdigest(), 16))[2:]
            binary2 = list(binary2)
            temp = bits[2] - len(binary2)
            for i in range(temp):
                binary2.insert(0, '0')

            binary = binary2 + binary1  # SHA-512 + SHA-256
            binary = np.array(list(map(lambda x: -1 if x == '0' else 1, binary)))
            hash_v = hash_v + binary

    elif gram == 4:
        opcode_ngram_tuple = list(ngrams(opcode_list, n=gram))

        for word1, word2, word3, word4 in opcode_ngram_tuple:

            opcode = word1 + word2 + word3 + word4

            binary1 = bin(int(h.sha256(opcode.encode()).hexdigest(), 16))[2:]
            binary1 = list(binary1)
            temp = bits[1] - len(binary1)
            for i in range(temp):
                binary1.insert(0, '0')

            binary2 = bin(int(h.sha512(opcode.encode()).hexdigest(), 16))[2:]
            binary2 = list(binary2)
            temp = bits[2] - len(binary2)
            for i in range(temp):
                binary2.insert(0, '0')

            binary = binary2 + binary1  # SHA-512 + SHA-256
            binary = np.array(list(map(lambda x: -1 if x == '0' else 1, binary)))
            hash_v = hash_v + binary

    return hash_v


def make_img_768(bits, width, height, save_path, gram=None):
    opcode_path = '/home/mayixuan/MCSC-Simhash/1/'
    file_list = os.listdir(opcode_path)

    if not os.path.exists(save_path):
        os.mkdir(save_path)

    for num, file in enumerate(file_list):

        with open(opcode_path + file, 'rb') as f:
            opcode_list = pickle.load(f)

        hash_list = make_hash_768(opcode_list, bits, gram)

        # let's make the image
        for index, each in enumerate(hash_list):
            if each > 0:
                hash_list[index] = 255.
            else:
                hash_list[index] = 0.

        image = np.asarray(hash_list, dtype=np.uint8).reshape(height, width)

        file = re.sub('.pkl', '.png', file)
        PATH = save_path + file
        io.imsave(PATH, image)


def make_hash(opcode_list, bits, gram):   # 应该是make_hash_248???
    hash_v = np.zeros([bits])

    if gram == None:

        for opcode in opcode_list:
            binary = bin(int(h.sha512(opcode.encode()).hexdigest(), 16))[2:]
            binary = list(binary)
            temp = bits - len(binary)

            for i in range(temp):
                binary.insert(0, '0')

            binary = np.array(list(map(lambda x: -1 if x == '0' else 1, binary)))
            hash_v = hash_v + binary

    elif gram == 2:

        opcode_ngram_tuple = list(ngrams(opcode_list, n=gram))

        for word1, word2 in opcode_ngram_tuple:

            opcode = word1 + word2

            binary = bin(int(h.sha512(opcode.encode()).hexdigest(), 16))[2:]
            binary = list(binary)
            temp = bits - len(binary)  # temp is for inserting '0' omitted automatically

            for i in range(temp):
                binary.insert(0, '0')

            binary = np.array(list(map(lambda x: -1 if x == '0' else 1, binary)))
            hash_v = hash_v + binary

    elif gram == 3:
        opcode_ngram_tuple = list(ngrams(opcode_list, n=gram))

        for word1, word2, word3 in opcode_ngram_tuple:

            opcode = word1 + word2 + word3

            binary = bin(int(h.sha512(opcode.encode()).hexdigest(), 16))[2:]
            binary = list(binary)
            temp = bits - len(binary)  # temp is for inserting '0' omitted automatically

            for i in range(temp):
                binary.insert(0, '0')

            binary = np.array(list(map(lambda x: -1 if x == '0' else 1, binary)))
            hash_v = hash_v + binary

    return hash_v


def make_img(bits, width, height, save_path, gram=None):   # 应该是make_img_248???
    opcode_path = '/home/mayixuan/MCSC-Simhash/1/'
    file_list = os.listdir(opcode_path)

    if not os.path.exists(save_path):
        os.mkdir(save_path)

    for num, file in enumerate(file_list):

        with open(opcode_path + file, 'rb') as f:
            opcode_list = pickle.load(f)

        hash_list = make_hash(opcode_list, bits, gram)

        # let's make the image
        for index, each in enumerate(hash_list):
            if each > 0:
                hash_list[index] = 255.
            else:
                hash_list[index] = 0.

        image = np.asarray(hash_list, dtype=np.uint8).reshape(height, width)

        file = re.sub('.pkl', '.png', file)
        PATH = save_path + file
        io.imsave(PATH, image)



# 1-gram
#t = TicToc()

#bits = 512
#width = 16
#height = 32
#save_path ='/home/mayixuan/MCSC-Simhash/new/image/1gram/'

#t.tic()
#make_img(bits, width, height, save_path, gram=1)  # default: 1garm
#t.toc()

#print(t.elapsed)




# 2-gram
#t = TicToc()

#bits = 512
#width = 16
#height = 32
#save_path ='/home/mayixuan/MCSC-Simhash/new/image/2gram/'

#t.tic()
#make_img(bits, width, height, save_path, gram=2)  # default: 1garm
#t.toc()

#print(t.elapsed)


# 3-gram
#t = TicToc()

#bits = 512
#width = 16
#height = 32
#save_path ='/home/mayixuan/MCSC-Simhash/new/image/3gram/'

#t.tic()
#make_img(bits, width, height, save_path, gram=3)  # default: 1garm
#t.toc()

#print(t.elapsed)



#from tqdm import tqdm
#from PIL import Image

#gram_list = ['1gram/', '2gram/', '3gram/']
#read_path = '/home/mayixuan/MCSC-Simhash/new/image/'

#image_gram_list = [[], [], []]
#file_name_l = []

#for i in tqdm(range(len(gram_list))):
#    temp = os.listdir(read_path + gram_list[i])

#    for file in temp:
#        PATH = read_path + gram_list[i] + file
#        temp_image = np.array(Image.open(PATH))
#        image_gram_list[i].append(temp_image)

#        file_name_l.append(PATH.split('/')[-1])

#file_index = 0

#for img1, img2, img3 in tqdm(zip(image_gram_list[0], image_gram_list[1], image_gram_list[2])):
#    img1 = np.expand_dims(img1, axis=0)
#    img2 = np.expand_dims(img2, axis=0)
#    img3 = np.expand_dims(img3, axis=0)

#    weighted_img = np.concatenate([img1, img2, img3], axis=0)

#    file_name = re.sub('.png', '', file_name_l[file_index])
#    PATH = read_path + 'weighted/' + file_name
#    np.save(PATH, weighted_img)

#    file_index += 1



#t = TicToc()

#bits = [768, 256, 512]
#bits1 = 256
#bits2 = 512

#width = 24
#height = 32
#save_path ='/home/mayixuan/MCSC-Simhash/drift/image/before/1gram_768/'

#t.tic()
#make_img_768(bits, width, height, save_path, gram=1)  # default: 1garm
#t.toc()

#print(t.elapsed)



#t = TicToc()

#bits = [768, 256, 512]
#bits1 = 256
#bits2 = 512

#width = 24
#height = 32
#save_path ='/home/mayixuan/MCSC-Simhash/new/image/2gram_768/'

#t.tic()
#make_img_768(bits, width, height, save_path, 2)  # default: 1garm
#t.toc()

#print(t.elapsed)



#t = TicToc()

bits = [768, 256, 512]
bits1 = 256
bits2 = 512

width = 24
height = 32
save_path ='/home/mayixuan/MCSC-Simhash/2/'

#t.tic()
make_img_768(bits, width, height, save_path, 3)  # default: 1garm
#t.toc()

#print(t.elapsed)





#from tqdm import tqdm
#from PIL import Image

#gram_list = ['1gram_768/', '2gram_768/', '3gram_768/']
#read_path = '/home/mayixuan/MCSC-Simhash/new/image/'

#image_gram_list = [[], [], []]
#file_name_l = []

#for i in tqdm(range(len(gram_list))):
#    temp = os.listdir(read_path + gram_list[i])

#    for file in temp:
#        PATH = read_path + gram_list[i] + file
#        temp_image = np.array(Image.open(PATH))
#        image_gram_list[i].append(temp_image)

#        file_name_l.append(PATH.split('/')[-1])

#file_index = 0

#if not os.path.exists(read_path + 'weighted_768'):
#    os.mkdir(read_path + 'weighted_768')

#for img1, img2, img3 in tqdm(zip(image_gram_list[0], image_gram_list[1], image_gram_list[2])):
#    img1 = np.expand_dims(img1, axis=0)
#    img2 = np.expand_dims(img2, axis=0)
#    img3 = np.expand_dims(img3, axis=0)

#    weighted_img = np.concatenate([img1, img2, img3], axis=0)

#    file_name = re.sub('.png', '', file_name_l[file_index])
#    PATH = read_path + 'weighted_768/' + file_name
#    np.save(PATH, weighted_img)

#    file_index += 1
